{"version":3,"file":"avrecording.min.js","sources":["../src/avrecording.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n//\n\n/**\n * JavaScript to the recording work.\n *\n * We would like to thank the creators of atto_recordrtc, whose\n * work originally inspired this.\n *\n * This script uses some third-party JavaScript and loading that within Moodle/ES6\n * requires some contortions. The main classes here are:\n *\n * * Recorder - represents one recording widget. This works in a way that is\n *   not particularly specific to this question type.\n * * RecordRtcQuestion - represents one question, which may contain several recorders.\n *   It deals with the interaction between the recorders and the question.\n *\n * @module    qtype_recordrtc/avrecording\n * @copyright 2019 The Open University\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Log from 'core/log';\nimport ModalFactory from 'core/modal_factory';\nimport Notification from 'core/notification';\n\n/**\n * Verify that the question type can work. If not, show a warning.\n *\n * @return {string} 'ok' if it looks OK, else 'nowebrtc' or 'nothttps' if there is a problem.\n */\nfunction checkCanWork() {\n    if (!(navigator.mediaDevices && window.MediaRecorder)) {\n        return 'nowebrtc';\n    }\n\n    if (!(location.protocol === 'https:' || location.host.indexOf('localhost') !== -1)) {\n        return 'nothttps';\n    }\n\n    return 'ok';\n}\n\nconst RecorderPromise = import(M.cfg.wwwroot + '/question/type/recordrtc/js/mp3-mediarecorder@4.0.5/worker.umd.js').then(() => {\n    return import(M.cfg.wwwroot + '/question/type/recordrtc/js/mp3-mediarecorder@4.0.5/index.umd.js');\n\n}).then(recorderModule => {\n    const Mp3MediaRecorder = recorderModule.Mp3MediaRecorder;\n\n    const workerURL = URL.createObjectURL(new Blob([\n        // Now load the script (UMD version) in the Workers context.\n        \"importScripts('\" + M.cfg.wwwroot + \"/question/type/recordrtc/js/mp3-mediarecorder@4.0.5/worker.umd.js');\",\n\n        // The above index.umd.js script exports all methods in a new mp3EncoderWorker object.\n        \"mp3EncoderWorker.initMp3MediaEncoder({vmsgWasmUrl: '\" +\n        M.cfg.wwwroot + \"/question/type/recordrtc/js/vmsg@0.4.0/vmsg.wasm'});\",\n    ], {type: 'application/javascript'}));\n\n    /**\n     * Object for actually doing the recording.\n     *\n     * The recorder can be in one of several states, which is stored in a data-state\n     * attribute on the outer span (widget). The states are:\n     *\n     *  - new:       there is no recording yet. Button shows 'Start recording' (audio) or 'Start camera' (video).\n     *  - starting:  (video only) camera has started, but we are not recording yet. Button show 'Start recording'.\n     *  - recording: Media is being recorded. Pause button visible if allowed. Main button shows 'Stop'. Countdown displayed.\n     *  - paused:    If pause was pressed. Media recording paused, but resumable. Pause button changed to say 'resume'.\n     *  - saving:    Media being uploaded. Progress indication shown. Pause button hidden if was visible.\n     *  - recorded:  Recording and upload complete. Buttons shows 'Record again'.\n     *\n     * @param {HTMLElement} widget the DOM node that is the top level of the whole recorder.\n     * @param {(AudioSettings|VideoSettings)} mediaSettings information about the media type.\n     * @param {Object} owner the object we are doing the recording for. Must provide three callback functions\n     *                       showAlert notifyRecordingComplete notifyButtonStatesChanged.\n     * @param {Object} uploadInfo object with fields uploadRepositoryId, draftItemId, contextId and maxUploadSize.\n     * @constructor\n     */\n    function Recorder(widget, mediaSettings, owner, uploadInfo) {\n        /**\n         * @type {Recorder} reference to this recorder, for use in event handlers.\n         */\n        const recorder = this;\n\n        /**\n         * @type {MediaStream} during recording, the stream of incoming media.\n         */\n        let mediaStream = null;\n\n        /**\n         * @type {MediaRecorder} the recorder that is capturing stream.\n         */\n        let mediaRecorder = null;\n\n        /**\n         * @type {Blob[]} the chunks of data that have been captured so far during the current recording.\n         */\n        let chunks = [];\n\n        /**\n         * @type {number} number of bytes recorded so far, so we can auto-stop\n         * before hitting Moodle's file-size limit.\n         */\n        let bytesRecordedSoFar = 0;\n\n        /**\n         * @type {number} when paused, the time left in milliseconds, so we can auto-stop at the time limit.\n         */\n        let timeRemaining = 0;\n\n        /**\n         * @type {number} while recording, the time we reach the time-limit, so we can auto-stop then.\n         * This is milliseconds since Unix epoch, so comparable with Date.now().\n         */\n        let stopTime = 0;\n\n        /**\n         * @type {number} intervalID returned by setInterval() while the timer is running.\n         */\n        let countdownTicker = 0;\n\n        const button = widget.querySelector('button.qtype_recordrtc-main-button');\n        const pauseButton = widget.querySelector('.qtype_recordrtc-pause-button button');\n        const controlRow = widget.querySelector('.qtype_recordrtc-control-row');\n        const mediaElement = widget.querySelector('.qtype_recordrtc-media-player ' + mediaSettings.name);\n        const noMediaPlaceholder = widget.querySelector('.qtype_recordrtc-no-recording-placeholder');\n        const timeDisplay = widget.querySelector('.qtype_recordrtc-time-left');\n\n        widget.addEventListener('click', handleButtonClick);\n        this.uploadMediaToServer = uploadMediaToServer; // Make this method available.\n\n        /**\n         * Handles clicks on the start/stop and pause buttons.\n         *\n         * @param {Event} e\n         */\n        function handleButtonClick(e) {\n            const clickedButton = e.target.closest('button');\n            if (!clickedButton) {\n                return; // Not actually a button click.\n            }\n            e.preventDefault();\n            switch (widget.dataset.state) {\n                case 'new':\n                case 'recorded':\n                    startRecording();\n                    break;\n                case 'starting':\n                    startSaving();\n                    break;\n                case 'recording':\n                    if (clickedButton === pauseButton) {\n                        pause();\n                    } else {\n                        stopRecording();\n                    }\n                    break;\n                case 'paused':\n                    if (clickedButton === pauseButton) {\n                        resume();\n                    } else {\n                        stopRecording();\n                    }\n                    break;\n            }\n        }\n\n        /**\n         * Start recording (because the button was clicked).\n         */\n        function startRecording() {\n\n            if (mediaSettings.name === 'audio') {\n                mediaElement.parentElement.classList.add('hide');\n                noMediaPlaceholder.classList.add('hide');\n                timeDisplay.classList.remove('hide');\n\n            } else {\n                mediaElement.parentElement.classList.remove('hide');\n                noMediaPlaceholder.classList.add('hide');\n            }\n            pauseButton?.parentElement.classList.remove('hide');\n\n            // Change look of recording button.\n            button.classList.remove('btn-outline-danger');\n            button.classList.add('btn-danger');\n\n            // Disable other question buttons when current widget stared recording.\n            disableAllButtons();\n\n            // Empty the array containing the previously recorded chunks.\n            chunks = [];\n            bytesRecordedSoFar = 0;\n            navigator.mediaDevices.getUserMedia(mediaSettings.mediaConstraints)\n                .then(handleCaptureStarting)\n                .catch(handleCaptureFailed);\n        }\n\n        /**\n         * Callback once getUserMedia has permission from the user to access the recording devices.\n         *\n         * @param {MediaStream} stream the stream to record.\n         */\n        function handleCaptureStarting(stream) {\n            mediaStream = stream;\n\n            // Setup the UI for during recording.\n            mediaElement.srcObject = stream;\n            mediaElement.muted = true;\n            if (mediaSettings.name === 'audio') {\n                startSaving();\n            } else {\n                mediaElement.play();\n                mediaElement.controls = false;\n\n                widget.dataset.state = 'starting';\n                setButtonLabel('startrecording');\n                widget.querySelector('.qtype_recordrtc-stop-button').disabled = false;\n            }\n\n            // Make button clickable again, to allow starting/stopping recording.\n            if (pauseButton) {\n                pauseButton.disabled = false;\n            }\n            button.disabled = false;\n            button.focus();\n        }\n\n        /**\n         * For recording types which show the media during recording,\n         * this starts the loop-back display, but does not start recording it yet.\n         */\n        function startSaving() {\n            // Initialize MediaRecorder events and start recording.\n            if (mediaSettings.name === 'audio') {\n                mediaRecorder = new Mp3MediaRecorder(mediaStream,\n                    {worker: new Worker(workerURL)});\n            } else {\n                const recordingOptions = getRecordingOptions();\n                try {\n                    mediaRecorder = new MediaRecorder(mediaStream, recordingOptions);\n                } catch (e) {\n                    Log.debug(e);\n                    if (recordingOptions.mimeType) {\n                        delete recordingOptions.mimeType;\n                        try {\n                            mediaRecorder = new MediaRecorder(mediaStream, recordingOptions);\n                        } catch (e) {\n                            Log.debug(e);\n                            new MediaRecorder(mediaStream);\n                        }\n                    } else {\n                        throw e;\n                    }\n                }\n            }\n\n            mediaRecorder.ondataavailable = handleDataAvailable;\n            mediaRecorder.onpause = handleDataAvailable;\n            mediaRecorder.onstop = handleRecordingHasStopped;\n            mediaRecorder.start(1000); // Capture in one-second chunks. Firefox requires that.\n\n            widget.dataset.state = 'recording';\n            setButtonLabel('stoprecording');\n            startCountdownTimer();\n            if (mediaSettings.name === 'video') {\n                button.parentElement.classList.add('hide');\n                controlRow.classList.remove('hide');\n                controlRow.classList.add('d-flex');\n            }\n        }\n\n        /**\n         * Callback that is called by the media system for each Chunk of data.\n         *\n         * @param {BlobEvent} event\n         */\n        function handleDataAvailable(event) {\n            if (!event.data) {\n                return; // It seems this can happen around pausing.\n            }\n\n            // Check there is space to store the next chunk, and if not stop.\n            bytesRecordedSoFar += event.data.size;\n            if (uploadInfo.maxUploadSize >= 0 && bytesRecordedSoFar >= uploadInfo.maxUploadSize) {\n\n                // Extra check to avoid alerting twice.\n                if (!localStorage.getItem('alerted')) {\n                    localStorage.setItem('alerted', 'true');\n                    stopRecording();\n                    owner.showAlert('nearingmaxsize');\n\n                } else {\n                    localStorage.removeItem('alerted');\n                }\n            }\n\n            // Store the next chunk of data.\n            chunks.push(event.data);\n\n            // Notify form-change-checker that there is now unsaved data.\n            // But, don't do this in question preview where it is just annoying.\n            if (typeof M.core_formchangechecker !== 'undefined' &&\n                !window.location.pathname.endsWith('/question/preview.php')) {\n                M.core_formchangechecker.set_form_changed();\n            }\n        }\n\n        /**\n         * Pause recording.\n         */\n        function pause() {\n            // Stop the count-down timer.\n            stopCountdownTimer();\n            setPauseButtonLabel('resume');\n            mediaRecorder.pause();\n            widget.dataset.state = 'paused';\n        }\n\n        /**\n         * Continue recording.\n         */\n        function resume() {\n            // Stop the count-down timer.\n            resumeCountdownTimer();\n            widget.dataset.state = 'recording';\n            setPauseButtonLabel('pause');\n            mediaRecorder.resume();\n        }\n\n        /**\n         * Start recording (because the button was clicked or because we have reached a limit).\n         */\n        function stopRecording() {\n            // Disable the button while things change.\n            button.disabled = true;\n\n            // Stop the count-down timer.\n            stopCountdownTimer();\n\n            // Update the button.\n            button.classList.remove('btn-danger');\n            button.classList.add('btn-outline-danger');\n            if (pauseButton) {\n                setPauseButtonLabel('pause');\n                pauseButton.parentElement.classList.add('hide');\n            }\n\n            // Ask the recording to stop.\n            mediaRecorder.stop();\n\n            // Also stop each individual MediaTrack.\n            const tracks = mediaStream.getTracks();\n            for (let i = 0; i < tracks.length; i++) {\n                tracks[i].stop();\n            }\n        }\n\n        /**\n         * Callback that is called by the media system once recording has finished.\n         */\n        function handleRecordingHasStopped() {\n            if (widget.dataset.state === 'new') {\n                // This can happens if an error occurs when recording is starting. Do nothing.\n                return;\n            }\n\n            // Set source of the media player.\n            const blob = new Blob(chunks, {type: mediaRecorder.mimeType});\n            mediaElement.srcObject = null;\n            mediaElement.src = URL.createObjectURL(blob);\n\n            // Show audio player with controls enabled, and unmute.\n            mediaElement.muted = false;\n            mediaElement.controls = true;\n            mediaElement.parentElement.classList.remove('hide');\n            noMediaPlaceholder.classList.add('hide');\n            mediaElement.focus();\n\n            if (mediaSettings.name === 'audio') {\n                timeDisplay.classList.add('hide');\n\n            } else {\n                button.parentElement.classList.remove('hide');\n                controlRow.classList.add('hide');\n                controlRow.classList.remove('d-flex');\n            }\n\n            // Ensure the button while things change.\n            button.disabled = true;\n            button.classList.remove('btn-danger');\n            button.classList.add('btn-outline-danger');\n            widget.dataset.state = 'recorded';\n\n            if (chunks.length > 0) {\n                owner.notifyRecordingComplete(recorder);\n            }\n        }\n\n        /**\n         * Function that handles errors from the recorder.\n         *\n         * @param {DOMException} error\n         */\n        function handleCaptureFailed(error) {\n            Log.debug('Audio/video question: error received');\n            Log.debug(error);\n\n            setPlaceholderMessage('recordingfailed');\n            setButtonLabel('recordagainx');\n            button.classList.remove('btn-danger');\n            button.classList.add('btn-outline-danger');\n            widget.dataset.state = 'new';\n\n            if (mediaRecorder) {\n                mediaRecorder.stop();\n            }\n\n            // Changes 'CertainError' -> 'gumcertain' to match language string names.\n            const stringName = 'gum' + error.name.replace('Error', '').toLowerCase();\n\n            owner.showAlert(stringName);\n            enableAllButtons();\n        }\n\n        /**\n         * Start the countdown timer.\n         */\n        function startCountdownTimer() {\n            timeRemaining = widget.dataset.maxRecordingDuration * 1000;\n            resumeCountdownTimer();\n            updateTimerDisplay();\n        }\n\n        /**\n         * Stop the countdown timer.\n         */\n        function stopCountdownTimer() {\n            timeRemaining = stopTime - Date.now();\n            if (countdownTicker !== 0) {\n                clearInterval(countdownTicker);\n                countdownTicker = 0;\n            }\n        }\n\n        /**\n         * Start or resume the countdown timer.\n         */\n        function resumeCountdownTimer() {\n            stopTime = Date.now() + timeRemaining;\n            if (countdownTicker === 0) {\n                countdownTicker = setInterval(updateTimerDisplay, 100);\n            }\n        }\n\n        /**\n         * Update the countdown timer, and stop recording if we have reached 0.\n         */\n        function updateTimerDisplay() {\n            const millisecondsRemaining = stopTime - Date.now();\n            const secondsRemaining = Math.round(millisecondsRemaining / 1000);\n            const secs = secondsRemaining % 60;\n            const mins = Math.round((secondsRemaining - secs) / 60);\n\n            timeDisplay.innerText = M.util.get_string('timedisplay', 'qtype_recordrtc',\n                    {mins: pad(mins), secs: pad(secs)});\n\n            if (millisecondsRemaining <= 0) {\n                stopRecording();\n            }\n        }\n\n        /**\n         * Zero-pad a string to be at least two characters long.\n         *\n         * @param {number} val e.g. 1 or 10\n         * @return {string} e.g. '01' or '10'.\n         */\n        function pad(val) {\n            const valString = val + '';\n\n            if (valString.length < 2) {\n                return '0' + valString;\n            } else {\n                return '' + valString;\n            }\n        }\n\n        /**\n         * Trigger the upload of the recorded media back to Moodle.\n         */\n        function uploadMediaToServer() {\n            setButtonLabel('uploadpreparing');\n\n            // First we need to get the media data from the media element.\n            const fetchRequest = new XMLHttpRequest();\n            fetchRequest.open('GET', mediaElement.src);\n            fetchRequest.responseType = 'blob';\n            fetchRequest.addEventListener('load', handleRecordingFetched);\n            fetchRequest.send();\n        }\n\n        /**\n         * Callback called once we have the data from the media element, ready to upload to Moodle.\n         *\n         * @param {ProgressEvent} e\n         */\n        function handleRecordingFetched(e) {\n            const fetchRequest = e.target;\n            if (fetchRequest.status !== 200) {\n                // No data.\n                return;\n            }\n\n            // Blob is now the media that the audio/video tag's src pointed to.\n            const blob = fetchRequest.response;\n\n            // Create FormData to send to PHP filepicker-upload script.\n            const formData = new FormData();\n            formData.append('repo_upload_file', blob, widget.dataset.recordingFilename);\n            formData.append('sesskey', M.cfg.sesskey);\n            formData.append('repo_id', uploadInfo.uploadRepositoryId);\n            formData.append('itemid', uploadInfo.draftItemId);\n            formData.append('savepath', '/');\n            formData.append('ctx_id', uploadInfo.contextId);\n            formData.append('overwrite', '1');\n\n            const uploadRequest = new XMLHttpRequest();\n            uploadRequest.addEventListener('readystatechange', handleUploadReadyStateChanged);\n            uploadRequest.upload.addEventListener('progress', handleUploadProgress);\n            uploadRequest.addEventListener('error', handleUploadError);\n            uploadRequest.addEventListener('abort', handleUploadAbort);\n            uploadRequest.open('POST', M.cfg.wwwroot + '/repository/repository_ajax.php?action=upload');\n            uploadRequest.send(formData);\n        }\n\n        /**\n         * Callback for when the upload completes.\n         * @param {ProgressEvent} e\n         */\n        function handleUploadReadyStateChanged(e) {\n            const uploadRequest = e.target;\n            if (uploadRequest.readyState !== 4) {\n                return; // Not finished yet. We will get more of these events when it is.\n            }\n\n            let response = '';\n            try {\n                response = JSON.parse(uploadRequest.responseText);\n            } catch (e) {\n                handleUploadError();\n                return;\n            }\n            if (response.errorcode) {\n                handleUploadError(); // Moodle sends back errors with a 200 status code for some reason!\n                return;\n            }\n\n            if (uploadRequest.status === 200) {\n                // When request finished and successful.\n                setButtonLabel('recordagainx');\n                enableAllButtons();\n            } else if (uploadRequest.status === 404) {\n                setPlaceholderMessage('uploadfailed404');\n                enableAllButtons();\n            }\n        }\n\n        /**\n         * Callback for updating the upload progress.\n         * @param {ProgressEvent} e\n         */\n        function handleUploadProgress(e) {\n            setButtonLabel('uploadprogress', Math.round(e.loaded / e.total * 100) + '%');\n        }\n\n        /**\n         * Callback for when the upload fails with an error.\n         */\n        function handleUploadError() {\n            setPlaceholderMessage('uploadfailed');\n            enableAllButtons();\n        }\n\n        /**\n         * Callback for when the upload fails with an error.\n         */\n        function handleUploadAbort() {\n            setPlaceholderMessage('uploadaborted');\n            enableAllButtons();\n        }\n\n        /**\n         * Display a progress message in the upload progress area.\n         *\n         * @param {string} langString\n         * @param {string|null} [a] optional variable to populate placeholder with\n         */\n        function setButtonLabel(langString, a) {\n            if (!a) {\n                // Seemingly unnecessary space inside the span is needed for screen-readers, and it must be a non-breaking space.\n                a = '<span class=\"sr-only\">&nbsp;' + widget.dataset.widgetName + '</span>';\n            }\n            button.innerHTML = M.util.get_string(langString, 'qtype_recordrtc', a);\n        }\n\n        /**\n         * Display a progress message in the upload progress area.\n         *\n         * @param {string} langString\n         */\n        function setPauseButtonLabel(langString) {\n            pauseButton.innerText = M.util.get_string(langString, 'qtype_recordrtc');\n        }\n\n        /**\n         * Display a message in the upload progress area.\n         *\n         * @param {string} langString\n         */\n        function setPlaceholderMessage(langString) {\n            noMediaPlaceholder.textContent = M.util.get_string(langString, 'qtype_recordrtc');\n            mediaElement.parentElement.classList.add('hide');\n            noMediaPlaceholder.classList.remove('hide');\n        }\n\n        /**\n         * Select best options for the recording codec.\n         *\n         * @returns {Object}\n         */\n        function getRecordingOptions() {\n            const options = {};\n\n            // Get the relevant bit rates from settings.\n            if (mediaSettings.name === 'audio') {\n                options.audioBitsPerSecond = mediaSettings.bitRate;\n            } else if (mediaSettings.name === 'video') {\n                options.audioBitsPerSecond = mediaSettings.audioBitRate;\n                options.videoBitsPerSecond = mediaSettings.videoBitRate;\n                options.videoWidth = mediaSettings.width;\n                options.videoHeight = mediaSettings.height;\n\n                // Go through our list of mimeTypes, and take the first one that will work.\n                for (let i = 0; i < mediaSettings.mimeTypes.length; i++) {\n                    if (MediaRecorder.isTypeSupported(mediaSettings.mimeTypes[i])) {\n                        options.mimeType = mediaSettings.mimeTypes[i];\n                        break;\n                    }\n                }\n            }\n\n            return options;\n        }\n\n        /**\n         * Enable all buttons in the question.\n         */\n        function enableAllButtons() {\n            disableOrEnableButtons(true);\n            owner.notifyButtonStatesChanged();\n        }\n\n        /**\n         * Disable all buttons in the question.\n         */\n        function disableAllButtons() {\n            disableOrEnableButtons(false);\n        }\n\n        /**\n         * Disables/enables other question buttons when current widget started recording/finished recording.\n         *\n         * @param {boolean} enabled true if the button should be enabled.\n         */\n        function disableOrEnableButtons(enabled = false) {\n            widget.closest('.que').querySelectorAll('button, input[type=submit], input[type=button]').forEach(\n                function(button) {\n                    button.disabled = !enabled;\n                }\n            );\n        }\n    }\n\n    return Recorder;\n});\n\n/**\n * Object that controls the settings for recording audio.\n *\n * @param {string} bitRate desired audio bitrate.\n * @constructor\n */\nfunction AudioSettings(bitRate) {\n    this.name = 'audio';\n    this.bitRate = parseInt(bitRate, 10);\n    this.mediaConstraints = {\n        audio: true\n    };\n    this.mimeTypes = [\n        'audio/mpeg',\n    ];\n}\n\n/**\n * Object that controls the settings for recording video.\n *\n * @param {string} audioBitRate desired video bitrate.\n * @param {string} videoBitRate desired video bitrate.\n * @param {string} width desired width.\n * @param {string} height desired height.\n * @constructor\n */\nfunction VideoSettings(audioBitRate, videoBitRate, width, height) {\n    this.name = 'video';\n    this.audioBitRate = parseInt(audioBitRate, 10);\n    this.videoBitRate = parseInt(videoBitRate, 10);\n    this.width = parseInt(width, 10);\n    this.height = parseInt(height, 10);\n    this.mediaConstraints = {\n        audio: true,\n        video: {\n            width: {ideal: this.width},\n            height: {ideal: this.height},\n            frameRate: {ideal: 24},\n        }\n    };\n    this.mimeTypes = [\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=h264,opus',\n        'video/webm;codecs=vp8,opus',\n        'video/mp4'\n    ];\n}\n\n/**\n * Represents one record audio or video question.\n *\n * @param {string} questionId id of the outer question div.\n * @param {Object} settings like audio bit rate.\n * @constructor\n */\nfunction RecordRtcQuestion(questionId, settings) {\n    const questionDiv = document.getElementById(questionId);\n\n    // Check if the RTC API can work here.\n    const result = checkCanWork();\n    if (result === 'nothttps') {\n        questionDiv.querySelector('.https-warning').classList.remove('hide');\n        return;\n    } else if (result === 'nowebrtc') {\n        questionDiv.querySelector('.no-webrtc-warning').classList.remove('hide');\n        return;\n    }\n\n    // Make the callback functions available.\n    this.showAlert = showAlert;\n    this.notifyRecordingComplete = notifyRecordingComplete;\n    this.notifyButtonStatesChanged = setSubmitButtonState;\n    const thisQuestion = this;\n\n    // We may have more than one widget in a question.\n    questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget').forEach(function(widget) {\n        // Get the appropriate options.\n        let typeInfo;\n        if (widget.dataset.mediaType === 'audio') {\n            typeInfo = new AudioSettings(settings.audioBitRate);\n        } else {\n            typeInfo = new VideoSettings(settings.audioBitRate, settings.videoBitRate, settings.videoWidth, settings.videoHeight);\n        }\n\n        // Create the recorder.\n        RecorderPromise.then(Recorder => {\n            new Recorder(widget, typeInfo, thisQuestion, settings);\n            return 'Not used';\n        }).catch(Notification.exception);\n    });\n    setSubmitButtonState();\n\n    /**\n     * Set the state of the question's submit button.\n     *\n     * If any recorder does not yet have a recording, then disable the button.\n     * Otherwise, enable it.\n     */\n    function setSubmitButtonState() {\n        let anyRecorded = false;\n        questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget').forEach(function(widget) {\n            if (widget.dataset.state === 'recorded') {\n                anyRecorded = true;\n            }\n        });\n        const submitButton = questionDiv.querySelector('input.submit[type=submit]');\n        if (submitButton) {\n            submitButton.disabled = !anyRecorded;\n        }\n    }\n\n    /**\n     * Show a modal alert.\n     *\n     * @param {string} subject Subject is the content of the alert (which error the alert is for).\n     * @return {Promise}\n     */\n    function showAlert(subject) {\n        return ModalFactory.create({\n            type: ModalFactory.types.ALERT,\n            title: M.util.get_string(subject + '_title', 'qtype_recordrtc'),\n            body: M.util.get_string(subject, 'qtype_recordrtc'),\n        }).then(function(modal) {\n            modal.show();\n            return modal;\n        });\n    }\n\n    /**\n     * Callback called when the recording is completed.\n     *\n     * @param {Recorder} recorder the recorder.\n     */\n    function notifyRecordingComplete(recorder) {\n        recorder.uploadMediaToServer();\n    }\n}\n\n/**\n * Initialise a record audio or video question.\n *\n * @param {string} questionId id of the outer question div.\n * @param {Object} settings like audio bit rate.\n */\nfunction init(questionId, settings) {\n    M.util.js_pending('init-' + questionId);\n    new RecordRtcQuestion(questionId, settings);\n    M.util.js_complete('init-' + questionId);\n}\n\nexport {\n    init\n};\n"],"names":["questionId","settings","M","util","js_pending","RecordRtcQuestion","js_complete","RecorderPromise","cfg","wwwroot","then","recorderModule","Mp3MediaRecorder","workerURL","URL","createObjectURL","Blob","type","widget","mediaSettings","owner","uploadInfo","recorder","this","mediaStream","mediaRecorder","chunks","bytesRecordedSoFar","timeRemaining","stopTime","countdownTicker","button","querySelector","pauseButton","controlRow","mediaElement","name","noMediaPlaceholder","timeDisplay","handleCaptureStarting","stream","srcObject","muted","startSaving","play","controls","dataset","state","setButtonLabel","disabled","focus","worker","Worker","recordingOptions","options","audioBitsPerSecond","bitRate","audioBitRate","videoBitsPerSecond","videoBitRate","videoWidth","width","videoHeight","height","i","mimeTypes","length","MediaRecorder","isTypeSupported","mimeType","getRecordingOptions","e","debug","ondataavailable","handleDataAvailable","onpause","onstop","handleRecordingHasStopped","start","maxRecordingDuration","resumeCountdownTimer","updateTimerDisplay","parentElement","classList","add","remove","event","data","size","maxUploadSize","localStorage","getItem","removeItem","setItem","stopRecording","showAlert","push","core_formchangechecker","window","location","pathname","endsWith","set_form_changed","stopCountdownTimer","setPauseButtonLabel","stop","tracks","getTracks","blob","src","notifyRecordingComplete","handleCaptureFailed","error","setPlaceholderMessage","stringName","replace","toLowerCase","enableAllButtons","Date","now","clearInterval","setInterval","millisecondsRemaining","secondsRemaining","Math","round","secs","mins","innerText","get_string","pad","val","valString","handleRecordingFetched","fetchRequest","target","status","response","formData","FormData","append","recordingFilename","sesskey","uploadRepositoryId","draftItemId","contextId","uploadRequest","XMLHttpRequest","addEventListener","handleUploadReadyStateChanged","upload","handleUploadProgress","handleUploadError","handleUploadAbort","open","send","readyState","JSON","parse","responseText","errorcode","loaded","total","langString","a","widgetName","innerHTML","textContent","disableOrEnableButtons","notifyButtonStatesChanged","enabled","closest","querySelectorAll","forEach","clickedButton","preventDefault","navigator","mediaDevices","getUserMedia","mediaConstraints","catch","startRecording","pause","resume","uploadMediaToServer","responseType","AudioSettings","parseInt","audio","VideoSettings","video","ideal","frameRate","questionDiv","document","getElementById","result","protocol","host","indexOf","subject","ModalFactory","create","types","ALERT","title","body","modal","show","setSubmitButtonState","thisQuestion","typeInfo","mediaType","Recorder","Notification","exception","anyRecorded","submitButton"],"mappings":"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"}